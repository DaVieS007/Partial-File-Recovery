/**
    Licensed under GNU/GPLv3
    Author: DaVieS at nPulse.net / Viktor Hlavaji
    Mail: davies@npulse.net
    Software is intended to recover files from a bad drive, written in pure C.
    Compile with: gcc -o pfr pfr.c | clang -o pfr pfr.c
**/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <time.h> 

#ifdef WIN32
    #include <windows.h>
#endif


#define EXIT_OK 0
#define EXIT_FAIL 1
#define VERSION "2.1r"
#define true 1
#define false 0
#define BUFFSZ 10485760
#define MBUFFSIZE 67108864

char *MBUFF;
FILE * src;
FILE * dst;

typedef char bool;
typedef long int _long;
typedef struct
{
    char *buffer;
    int slen;
} storage;


void signalHandler( int signum ) 
{
    fprintf(stderr,"\n\nExiting ....\n");
    fflush(stderr);

    if(dst != NULL)
    {
        fflush(dst);
        fclose(dst);
    }

    if(src != NULL)
    {
        fclose(src);
    }

    exit(signum);  
}


int main(int argc, char *argv[])
{
    src = NULL;
    dst = NULL;
    unsigned int i;
    char ch;
    _long src_size = 0;
    _long dst_size = 0;
    _long rlen = 0;
    _long cur_pointer = 0;
    _long retries = 1;
    _long writes = 0;
    bool differental = false;
    _long limit = 0;
    _long skip = 512;
    _long seek = 0;  
    _long slimit = 0;
    int trPID = 0;
    char fill[3];
    char *tmp;
    char *tmp2;
    char _fill[2];
    _long badBlocks = 0;
    _long rbadBlocks = 0;
    _long retry = 0;
    storage buff;
    size_t slen,plen,slen2;
    bool success;
    time_t st = 0;
    time_t ct = 0;
    _long llast = 0;
    float progress;
    int MBPS;
    bool badBlock;
    bool readAhead;
    int clean;
    int emulate_badsector = 0;
    bool skip_write = false;
    int cc = 0;

    tmp = malloc(BUFFSZ*2);
    tmp2 = malloc(BUFFSZ*2);

    signal(SIGINT, signalHandler);

    /** ENABLE COLORED OUTPUT ON WINDOWS **/
    #ifdef WIN32
        HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
        if (hOut != INVALID_HANDLE_VALUE)
        {
            DWORD dwMode = 0;
            if (GetConsoleMode(hOut, &dwMode))
            {                    
                dwMode |= ENABLE_PROCESSED_OUTPUT | ENABLE_VIRTUAL_TERMINAL_PROCESSING | ENABLE_PROCESSED_INPUT;

                if (SetConsoleMode(hOut, dwMode))
                {

                }
            }                
        }
    #endif
    /** ENABLE COLORED OUTPUT ON WINDOWS **/

    fill[0] = 0x00;
    strcat(fill,"00");

    fprintf(stderr,"\n\n\033[7m[P]artial [F]ile [R]ecovery Version: %s\033[m\n",VERSION);

    if(argc < 3)
    {
        fprintf(stderr,"\033[96mThis software intended to rescue data. This software allows you to ignore and skip hard drive errors, and continue the operation with *possible* data loss.\n");
        fprintf(stderr,"Even the most secure filesystems could have data corruption like ZFS. This software intended - with fine tuning options - to retrieve the data regardless of data loss\n");
        fprintf(stderr,"In our research we concluded that restoring files or block devices with possible of data loss, does not mean that the data must have corrupted\n\n");
        fprintf(stderr,"Prior version 2.0 we added differential method to allow minimize writes. This is very handy when double reading better than writes.\nFor instance restoring old snapshots or differential clones back to itself.\n");
        fprintf(stderr,"Author: Viktor Hlavaji aka DaVieS, davies@npulse.net | Licensed under: GNU/GPLv3\033[m\n\n");

        fprintf(stderr,"\033[93mPlease make a backup and test before you use this software to data recovery, software comes without any warranty.\033[m\n\n");
        

        fprintf(stderr,"\033[1mUsage: %s [source_file] [dest_file] [differental = 0] [throttle = 0] [try = 1] [fill = 00] [skip = 512] [seek = 0] [endpos = 0]\033[m\n\n",argv[0]);
        fprintf(stderr,"\033[93m - source_file: The file that needs recover\n");
        fprintf(stderr," - dest_file: Output file will generated by this software\n");
        fprintf(stderr," - differental: (Optional) 0 = no, 1 = yes\n");
        fprintf(stderr,"   | - scan both input & output but only differences will be overwrite, could be handy when write operations makes heavy impact\n");
        fprintf(stderr," - throttle: (Optional) 0 = no limit, throttle down speed to [ x ] amount MB/s\n");
        fprintf(stderr," - try: (Optional) number of attempts to read a badSector\n");
        fprintf(stderr," - fill: (Optional) unrecovered bytes will replaced by hexCode 0x[XX]\n");
        fprintf(stderr," - skip: (Optional) On read error skip the next (x) bytes, should match with sectorsize or blocksize\n");
        fprintf(stderr," - seek: (Optional) Start reading from seek position\n");
        fprintf(stderr," - endpos: (Optional) Reading until end position\033[m\n\n");

        fprintf(stderr,"\033[1m[Example Software Output]\033[m\n");
        fprintf(stderr,"Operation    | Current Block | Round Left | Lost Blocks |  Recovered  | Written Bytes | Acquired Blocks | Progress, Speed\n");
        fprintf(stderr,"Fast Forward |             0 |          0 |           0 |           0 |             0 |              0  |  0.00, 0 MB/s\n");
        fprintf(stderr,"Fast Forward |     230686720 |          0 |           0 |           0 |             0 |      230686720  |  11.59, 220 MB/s\n\n");

        fprintf(stderr,"\033[1m[Examples to acquire damaged file]\033[m\n");
        fprintf(stderr,"To rescue a single file: %s ./broken_file.mp3 ./broken_file_fix.mp3\n",argv[0]);
        fprintf(stderr,"To rescue mySQL ibd: %s ./important_tbl.ibd ./important_tbl.ibd.bck\n",argv[0]);
        fprintf(stderr,"To rescue text file: %s ./mail.txt ./mail.txt.bck 0 0 1 20\n",argv[0]);

        fprintf(stderr,"\n\033[1m[Examples to rescue whole block device]\033[m\n");
        fprintf(stderr,"To rescue a 4K Sata BAD drive: %s /dev/sda /dev/sdb 0 0 1 00 4096\n",argv[0]);
        fprintf(stderr,"To rescue a 512B Sata partition: %s /dev/sda1 /dev/sdb1 0 0 1 00 512\n",argv[0]);
        fprintf(stderr,"To rescue a 512B Sata partition with limit of 22MB/s: %s /dev/sda1 /dev/sdb1 0 22 1 00 512\n",argv[0]);

        fprintf(stderr,"\n\033[1m[Example of differential method]\033[m\n");
        fprintf(stderr,"To copy changes only (differential copy) from file1 into file2 %s ./file1.img.old ./file2.img 1\n",argv[0]);

        return EXIT_FAIL;
    }

    if(argc >= 10)
    {
        limit = strtoull(argv[9],NULL,10);
    }

    if(argc >= 9)
    {
        seek = strtoull(argv[8],NULL,10);
    }

    if(argc >= 8)
    {
        skip = atoi(argv[7]);
    }

    if(argc >= 7)
    {
        if(strlen(argv[6]) != 2)
        {
            fprintf(stderr,"Invalid Argument\n");
            return EXIT_FAIL;
        }

        fill[0] = 0x00;

        for(i=0;i<=255;i++)
        {
            tmp[0] = 0x00;
            sprintf(tmp,"%02X",i);
            if(!strcmp(argv[6],tmp))
            {
                strcat(fill,tmp);
                _fill[0] = (char)i;
                _fill[1] = 0x00;
            }
        }

        if(fill[0] == 0x00)
        {
            fprintf(stderr,"Invalid Argument\n");
            return EXIT_FAIL;
        }
    }

    if(argc >= 6)
    {
        retries = atoi(argv[5]);
        if(retries <= 0)
        {
            retries = 1;
        }
    }

    if(argc >= 5)
    {
        slimit = atoi(argv[4]);
        if(slimit <= 0)
        {
            slimit = 0;
        }
    }

    if(argc >= 4)
    {
        if(atoi(argv[3]) > 0)
        {
            differental = true;
            fprintf(stderr,"\033[96mContinuing as Differential Mode, we are going to scan source and destination and only different blocks going to be overwrite\033[m\n");
        }
    }


    if(!differental)
    {
        fprintf(stderr,"\033[1mContinuing as Normal Mode, we are going to scan source and write to the destination immediately\033[m\n");
    }



    src = fopen (argv[1],"r");
    if (src == NULL)
    {
        fprintf(stderr,"Unable to open source file for reading: %s\n\n",argv[1]);
        return EXIT_FAIL;
    }    
    else
    {
        if(fseek(src,0,SEEK_END) != 0)
        {
            fprintf(stderr,"File is unrecoverable, seek failed: %s\n\n",argv[1]);
            fclose (src);
            return EXIT_FAIL;
        }
        src_size = ftell(src); 
        if(src_size <= 0)       
        {
            fprintf(stderr,"File is unrecoverable, seek failed: %s\n\n",argv[1]);
            fclose (src);
            return EXIT_FAIL;
        }
    }

    dst = fopen (argv[2],"r+");
    if (dst == NULL)
    {
        if(differental)
        {
            fprintf(stderr,"Unable to open destination file for differental writing: %s\n\n",argv[2]);
            fclose (src);
            return EXIT_FAIL;
        }

        dst = fopen (argv[2],"w");
        if (dst == NULL)
        {
            fprintf(stderr,"Unable to open destination file for writing: %s\n\n",argv[2]);
            fclose (src);
            return EXIT_FAIL;
        }  

    }


    MBUFF = malloc(MBUFFSIZE);
    buff.buffer = malloc(BUFFSZ*2);

    buff.buffer[0] = 0x00;
    buff.slen = 0;


    MBUFF[0] = 0x00;
    setvbuf(dst, MBUFF, _IOFBF, MBUFFSIZE);  

    /** INIT **/
    cur_pointer = seek;
    fseek(src,cur_pointer,SEEK_SET);
    /** INIT **/


    if(limit > 0)
    {
        src_size = limit;
    }

    if(seek > 0)
    {
        if(fseek(dst,0,SEEK_END) == 0)
        {
            dst_size = ftell(dst); 
        }

        if(seek > dst_size)
        {
            fprintf(stderr,"Error: Destination is smaller than the starting position!\n\n");
            fclose (src);
            fclose (dst);

            free(tmp);
            free(tmp2);
            free(MBUFF);
            free(buff.buffer);
            return EXIT_FAIL;
        }
        fseek(dst,cur_pointer,SEEK_SET);
    }


    fprintf(stdout,"\n");
    fprintf(stdout,"Source File Opened Successfully: %s\n",argv[1]);
    fprintf(stdout,"Destination File Opened Successfully: %s\n",argv[2]);
    fprintf(stdout,"Total Bytes to recover: %ld\n",src_size);
    fprintf(stdout,"badBlock Try Count: %li\n",retries);
    fprintf(stdout,"badBlock fill char: 0x%s\n",fill);
    fprintf(stdout,"skip count / sectorsize: %li\n",skip);
    fprintf(stdout,"Reading Start Position: %li\n",seek);

    if(slimit > 0)
    {
        fprintf(stdout,"Speed Throttle: %ld MB/s\n",slimit);
    }

    if(limit > 0)
    {
        fprintf(stdout,"Reading End Position: %li\n\n",limit);
    }

    fprintf(stdout,"\n");
    readAhead = true;


    while(true)
    {
        success = false;
        badBlock = false;
        retry = retries;

        if(!readAhead && clean >= 4096)
        {
            readAhead = true;
        }

        if(readAhead)
        {
            if(buff.slen > 0)
            {
                if(fwrite(buff.buffer,1,buff.slen,dst) != buff.slen)
                {
                    fprintf(stderr,"Failed to Write Destination [1] %d!",buff.slen);

                    free(tmp);
                    free(tmp2);
                    free(MBUFF);
                    free(buff.buffer);

                    fclose(src);
                    fclose(dst);

                    return EXIT_FAIL;                        
                }

                writes += buff.slen;
                buff.slen = 0;
                buff.buffer[0] = 0x00;
            }


            if(st != time(NULL))
            {
                if(cc++ % 20 == 0 || ct == 0)
                {
                    fprintf(stderr,"\033[7mOperation    | Current Block | Round Left | Lost Blocks |  Recovered  | Written Bytes | Acquired Blocks | Progress, Speed\033[m\n");
                }

                if(ct == 0)
                {
                    ct = time(NULL);
                    llast = cur_pointer;
                    MBPS = 0;
                }

                if(llast != cur_pointer)
                {
                    int secs = time(NULL) - ct;
                    MBPS = ((cur_pointer - llast) / secs) / 1024 / 1024;
                    ct = time(NULL);
                    llast = cur_pointer;
                }

                progress = (float)((double)(double)100/(double)src_size)*(double)cur_pointer;
                fprintf(stdout,"Fast Forward | %13ld | %10li | %11ld | %11ld | %13ld |  %13ld  |  %.2f, %d MB/s\n",cur_pointer,(retry - 1),badBlocks,rbadBlocks,writes,(cur_pointer - badBlocks),progress,MBPS);
                st = time(NULL);
                if(slimit > 0)
                {
                    if(MBPS > slimit && cc < 3)
                    {
                        trPID = 500;
                    }
                    else if(MBPS > slimit)
                    {
                        trPID += 50;
                    }
                    else if(MBPS < slimit && trPID > 100)
                    {
                        trPID -= 50;
                    }
                    usleep(trPID*1000);
                }
            }

            tmp[0] = 0x00;

            rlen = src_size - cur_pointer;
            if(rlen <= 0)
            {
                break; // WE FINISHED READ
            }
            else if(rlen > BUFFSZ)
            {
                rlen = BUFFSZ;
            }

            slen = fread (tmp, 1, rlen, src);
            if(emulate_badsector > 0 && cur_pointer > emulate_badsector && cur_pointer < (emulate_badsector + 262144))
            {
                fseek(src,cur_pointer,SEEK_SET);
                readAhead = false;
                clean = 0;
            }
            else
            {
                if(slen == rlen)
                {
                    if(differental)
                    {

/* A 4yr old's contribution
0                
 ,űŰ
-> mn;íł v5tcnchfcf vhb7z7hmi ,m,kl nl.é.
*/

                        tmp2[0] = 0x00;
                        fseek(dst,cur_pointer,SEEK_SET);
                        slen2 = fread (tmp2, 1, rlen, dst);


                        if(slen2 == slen && !memcmp(tmp,tmp2,rlen) )
                        {
                            skip_write = true;
                        }
                    }

                    if(skip_write)
                    {
                        skip_write = false;
                    }
                    else
                    {
                        fseek(dst,cur_pointer,SEEK_SET);
                        rlen = fwrite(tmp,1,slen,dst);
                        if(rlen != slen)
                        {
                            fprintf(stderr,"Failed to Write Destination [1] %lu!",rlen);

                            free(tmp);
                            free(tmp2);
                            free(MBUFF);
                            free(buff.buffer);

                            fclose(src);
                            fclose(dst);

                            return EXIT_FAIL;                        
                        }
                        writes += rlen;
                    }

                    cur_pointer = ftell(src);
                    continue;
                }            
                else
                {
                    if(slen > 0)
                    {
                        if(fwrite(tmp,1,slen,dst) != slen)
                        {
                            fprintf(stderr,"Failed to Write Destination [1] %lu!",slen);

                            free(tmp);
                            free(tmp2);
                            free(MBUFF);
                            free(buff.buffer);

                            fclose(src);
                            fclose(dst);

                            return EXIT_FAIL;                        
                        }

                        writes += slen;
                        cur_pointer += slen;
                        fseek(src,cur_pointer,SEEK_SET);
                        readAhead = false;
                        clean = 0;
                    }
                }
            }
        }

        while(retry-- > 0)
        {
            fseek(src,cur_pointer,SEEK_SET);

            if(st != time(NULL))
            {
                progress = (float)((double)(double)100/(double)src_size)*(double)cur_pointer;
                fprintf(stdout,"Block Mining | %13ld | %10li | %11ld | %11ld | %13ld |  %13ld  |  %.2f, -- MB/s\n",cur_pointer,(retry - 1),badBlocks,rbadBlocks,writes,(cur_pointer - badBlocks),progress);
                st = time(NULL);
            }

            if(feof(src))
            {
                badBlock = true;
                fclose(src);
                src = fopen (argv[1],"r");
                if (src == NULL)
                {
                    fprintf(stderr,"Unable to open source file for reading: %s\n\n",argv[1]);

                    free(tmp);
                    free(tmp2);
                    free(MBUFF);
                    free(buff.buffer);

                    fclose(src);
                    fclose(dst);

                    return EXIT_FAIL;
                }    

                fseek(src,cur_pointer,SEEK_SET);
            }

            tmp[0] = 0x00;
            slen = fread (tmp, 1, 1, src);
            if(emulate_badsector > 0 && cur_pointer > emulate_badsector && cur_pointer < (emulate_badsector + 262144))
            {
                badBlock = true;
                continue;
            }
            else
            {
                if(slen == 1)
                {
                    buff.buffer[buff.slen] = tmp[0];
                    buff.slen++;

                    if(buff.slen >= BUFFSZ) // CACHING !!
                    {
                        if(fwrite(buff.buffer,1,buff.slen,dst) != buff.slen)
                        {
                            fprintf(stderr,"Failed to Write Destination!");

                            free(tmp);
                            free(tmp2);
                            free(MBUFF);
                            free(buff.buffer);

                            fclose(src);
                            fclose(dst);

                            return EXIT_FAIL;                        
                        }

                        writes += buff.slen;
                        buff.slen = 0;
                        buff.buffer[0] = 0x00;
                    }

                    success = true;
                    clean++;
                    break;
                }
                else
                {
                    badBlock = true;
                    continue;
                }
            }
        }

        if(success == false)
        {
            clean = 0;
            for(i=0;i<skip;i++)
            {
                badBlocks++;
                cur_pointer++;
                buff.buffer[buff.slen] = _fill[0];
                buff.slen++;

                if(buff.slen >= BUFFSZ) // CACHING !!
                {
                    if(fwrite(buff.buffer,1,buff.slen,dst) != buff.slen)
                    {
                        fprintf(stderr,"Failed to Write Destination!");

                        free(tmp);
                        free(tmp2);
                        free(MBUFF);
                        free(buff.buffer);

                        fclose(src);
                        fclose(dst);

                        return EXIT_FAIL;                        
                    }

                    writes += buff.slen;
                    buff.slen = 0;
                    buff.buffer[0] = 0x00;
                }

                if(cur_pointer >= src_size)
                {
                    break;
                }
            }
        }
        else if(badBlock)
        {
            rbadBlocks++;
            cur_pointer++;
        }
        else
        {
            cur_pointer++;
        }

        if(cur_pointer >= src_size)
        {
            break;
        }
    }

    if(buff.slen > 0)
    {
        if(fwrite(buff.buffer,1,buff.slen,dst) != buff.slen)
        {
            fprintf(stderr,"Failed to Write Destination [1] %d!",buff.slen);
            free(tmp);
            free(tmp2);
            free(MBUFF);
            free(buff.buffer);

            fclose(src);
            fclose(dst);

            return EXIT_FAIL;                        
        }

        writes += buff.slen;
        buff.slen = 0;
        buff.buffer[0] = 0x00;
    }


    fclose(src);
    fclose(dst);

    fprintf(stderr,"Finished     | %13ld | %10li | %11ld | %11ld | %13ld |  %13ld  |  %.2f, -- MB/s\n",cur_pointer,(retry - 1),badBlocks,rbadBlocks,writes,(cur_pointer - badBlocks),100.00);

    free(tmp);
    free(tmp2);
    free(MBUFF);
    free(buff.buffer);
   
    return EXIT_OK;
}
